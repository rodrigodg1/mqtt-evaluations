"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var getTime = (function () {
    if (typeof performance !== "undefined") {
        return performance.now.bind(performance);
    }
    if (typeof process !== "undefined" && process.hrtime) {
        return function () {
            var _a = process.hrtime(), sec = _a[0], nanosec = _a[1];
            return (sec * 1e9 + nanosec) / 1e6;
        };
    }
    return Date.now.bind(Date);
})();
function benchmark(fn, bytes) {
    var elapsed = 0;
    var iterations = 0;
    var runsPerIteration = 1;
    // Run once without measuring anything to possibly kick-off JIT.
    fn();
    while (true) {
        var startTime = void 0;
        var diff = void 0;
        if (runsPerIteration === 1) {
            // Measure one iteration.
            startTime = getTime();
            fn();
            diff = getTime() - startTime;
        }
        else {
            // Measure many iterations.
            startTime = getTime();
            for (var i = 0; i < runsPerIteration; i++) {
                fn();
            }
            diff = getTime() - startTime;
        }
        // If diff is too small, double the number of iterations
        // and start over without recording results.
        if (diff < 1) {
            runsPerIteration *= 2;
            continue;
        }
        // Otherwise, record the result.
        elapsed += diff;
        iterations += runsPerIteration;
        if (elapsed > 500 && iterations > runsPerIteration * 2) {
            break;
        }
    }
    // Calculate average time per iteration.
    var avg = elapsed / iterations;
    return {
        iterations: iterations,
        msPerOp: avg,
        opsPerSecond: 1000 / avg,
        bytesPerSecond: bytes ? 1000 * (bytes * iterations) / (avg * iterations) : undefined
    };
}
exports.benchmark = benchmark;
function benchmarkAsync(fn, doneCallback, bytes) {
    var elapsed = 0;
    function run(todo, startTime, runDone) {
        fn(function () {
            todo -= 1;
            if (todo > 0) {
                run(todo, startTime, runDone);
                return;
            }
            runDone(getTime() - startTime);
        });
    }
    function next(iterations, runsPerIteration) {
        if (iterations === void 0) { iterations = 0; }
        if (runsPerIteration === void 0) { runsPerIteration = 1; }
        run(runsPerIteration, getTime(), function (diff) {
            // If diff is too small, double the number of iterations
            // and start over without recording results.
            if (diff < 1) {
                setTimeout(function () { next(iterations, runsPerIteration * 2); }, 0);
                return;
            }
            // Otherwise, record the result.
            elapsed += diff;
            iterations += runsPerIteration;
            if (elapsed > 500 && iterations > runsPerIteration * 2) {
                // We're done.
                var avg = elapsed / iterations;
                doneCallback({
                    iterations: iterations,
                    msPerOp: avg,
                    opsPerSecond: 1000 / avg,
                    bytesPerSecond: bytes ? 1000 * (bytes * iterations) / (avg * iterations) : undefined
                });
                return;
            }
            // Continue iterating.
            next(iterations, runsPerIteration);
        });
    }
    // Run once without measuring anything to possibly kick-off JIT
    // and then start benchmarking.
    run(1, getTime(), function () { return next(); });
}
exports.benchmarkAsync = benchmarkAsync;
function benchmarkPromise(fn, bytes) {
    return new Promise(function (resolve) {
        benchmarkAsync(function (done) { return fn().then(done); }, function (results) { return resolve(results); }, bytes);
    });
}
exports.benchmarkPromise = benchmarkPromise;
function report(name, results) {
    var ops = results.iterations + " ops";
    var msPerOp = results.msPerOp.toFixed(2) + " ms/op";
    var opsPerSecond = results.opsPerSecond.toFixed(2) + " ops/sec";
    var mibPerSecond = results.bytesPerSecond
        ? (results.bytesPerSecond / 1024 / 1024).toFixed(2) + " MiB/s"
        : "";
    console.log(pad(name, 30, true) + " " +
        pad(ops, 20) + " " +
        pad(msPerOp, 20) + " " +
        pad(opsPerSecond, 20) + " " +
        pad(mibPerSecond, 15));
}
exports.report = report;
function pad(s, upto, end) {
    if (end === void 0) { end = false; }
    var padlen = upto - s.length;
    if (padlen <= 0) {
        return s;
    }
    // XXX: in ES2015 we can use " ".repeat(padlen)
    var padding = new Array(padlen + 1).join(" ");
    if (end) {
        return s + padding;
    }
    return padding + s;
}
/**
 * Returns a Uint8Array of the given length containing
 * sequence of bytes 0, 1, 2 ... 255, 0, 1, 2, ...
 *
 * If the start byte is given, the sequence starts from it.
 */
function byteSeq(length, start) {
    if (start === void 0) { start = 0; }
    var b = new Uint8Array(length);
    for (var i = 0; i < b.length; i++) {
        b[i] = (start + i) & 0xff;
    }
    return b;
}
exports.byteSeq = byteSeq;
//# sourceMappingURL=benchmark.js.map